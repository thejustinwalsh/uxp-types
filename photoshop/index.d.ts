// Part 0 - Generated by https://github.com/hansottowirtz/adobe-uxp-types-crawler
declare module 'photoshop' {
    interface BatchPlayCommandOptions {
        readonly historyStateInfo?: HistoryStateInfo;
        readonly modalBehavior?: "wait" | "execute" | "fail";
        readonly propagateErrorToDefaultHandler?: boolean;
    }

    interface BuiltinWarp extends Warp{
        /**
         * Inherited from Warp.bounds
         * Rectangular bounds of the warp definition.
         */
        readonly bounds: Rectangle;
        /**
         * Distortion factor in the horizontal axis (percent)
         * default 0
         */
        readonly perspectiveH?: number;
        /**
         * Distortion factor in the vertical axis (percent)
         * default 0
         */
        readonly perspectiveV?: number;
        /**
         * The built-in style of warp to be applied.
         */
        readonly style: BuiltinWarpStyle;
        /**
         * Warp bend amount in percentage. [-100, 100]
         * default 50
         */
        readonly value?: number;
        /**
         * Whether to apply the built-in warp rotated 90 degrees CCW.
         * default false
         */
        readonly vertical?: boolean;
    }

    /**
     * Represents a simple 4x4 warp that can be applied to a Transformable.
     * This is the first 'Warp' tool that appears when a user goes to the Warp menu item.
     * Splitting the warp grid further, or selecting a different size of grid forces the warp to become a quilt warp.
     */
    interface CustomWarp4X4 extends Warp{
        /**
         * Inherited from Warp.bounds
         * Rectangular bounds of the warp definition.
         */
        readonly bounds: Rectangle;
        /**
         * 4x4 grid of points to represent the warp mesh.
         * Must contain exactly 16 points.
         */
        readonly meshPoints: PixelPoint[];
    }

    interface NotificationEvent {
        readonly event: string;
        readonly universal?: boolean;
    }

    interface PixelPoint {
        readonly x: number;
        readonly y: number;
    }

    interface Rectangle {
        readonly bottom: number;
        readonly left: number;
        readonly right: number;
        readonly top: number;
    }

    interface Scheduling {
        readonly eventLevel?: number;
        readonly playLevel?: number;
        readonly timeOut?: number;
    }

    interface Transformable {
        nudge(horizontal: number | PercentValue | PixelValue, vertical: number | PercentValue | PixelValue): Promise<void>;
        perspectiveTransform(percentH: number | PercentValue, percentV: number | PercentValue, interpolation?: InterpolationMethod): Promise<void>;
        rotate(angle: number | AngleValue, interpolation?: InterpolationMethod): Promise<void>;
        scale(width: number | PercentValue, height: number | PercentValue, interpolation?: InterpolationMethod): Promise<void>;
        skew(angleH: number | AngleValue, angleV: number | AngleValue, interpolation?: InterpolationMethod): Promise<void>;
        warp(warp: BuiltinWarp | CustomWarp4X4, interpolation?: InterpolationMethod): Promise<void>;
    }

    interface Warp {
        /**
         * Rectangular bounds of the warp definition.
         */
        readonly bounds: Rectangle;
    }

    /**
     * The module that facilitates Actions being performed in the
     * UXP-Photoshop world. You may perform your own batchPlay commands,
     * or attach listeners using this module.
     * @example 
     * var PhotoshopAction = require('photoshop').action;
     */
    interface PhotoshopAction {
        /**
         * Attach a listener to a Photoshop event. A callback in the form
         * of (eventName: string, descriptor: Descriptor) => void will be performed.
         * @example 
         * await PhotoshopAction.addNotificationListener([{ event: 'open' }], onOpenNewDocument)
         */
        addNotificationListener(events: NotificationEvent[], notifier: NotificationListener): Promise<void>;
        /**
         * Performs a batchPlay call with the provided commands. Equivalent
         * to an executeAction in ExtendScript.
         * @example 
         * var target = { _ref: 'layer', _enum: 'ordinal', _value: 'targetEnum'}
         * var commands = [{ _obj: 'hide', _target: target }]
         * await PhotoshopAction.batchPlay(commands)
         */
        batchPlay(commands: ActionDescriptor[], options?: BatchPlayCommandOptions): Promise<ActionDescriptor[]>;
        /**
         * Detaches a listener from a Photoshop event.
         * see addNotificationListener
         * @example 
         * await PhotoshopAction.removeNotificationListener([{ event: 'open' }], onOpenNewDocument)
         */
        removeNotificationListener(events: NotificationEvent[], notifier: NotificationListener): Promise<void>;
    }

    /**
     * The module that allows access to specialized commands
     * within the application. Various application state can be
     * modified or queried here.
     * @example 
     * var PhotoshopCore = require('photoshop').core;
     */
    interface PhotoshopCore {
        /**
         * Returns the effective size of a dialog.
         * @example 
         * var idealSize = { width: 200, height: 500 }
         * { width, height} = await PhotoshopCore.calculateDialogSize(idealSize)
         */
        calculateDialogSize(preferredSize: {
            height: number;
            width: number;
        }, identifier?: string, minimumSize?: {
            height: number;
            width: number;
        }): Promise<object>;
        /**
         * End the current modal tool editing state.
         * @example 
         * // close the modal dialog, cancelling changes
         * await PhotoshopCore.endModalToolState(false)
         */
        endModalToolState(commit: boolean): Promise<void>;
        /**
         * Returns information about the active Photoshop tool.
         * @example 
         * { title } = await PhotoshopCore.getActiveTool()
         */
        getActiveTool(): Promise<object>;
        /**
         * Returns whether a command menu item is available for invoking.
         * @example 
         * // can a Fill be performed?
         * var canFill = await PhotoshopCore.getMenuCommandState({ commandID: 1042 })
         */
        getMenuCommandState(options: {
            commandID: number;
            scheduling: Scheduling;
        }): Promise<boolean>;
        /**
         * Returns the localized menu title of the menu command item.
         * @example 
         * var renameLayerStr = await PhotoshopCore.getMenuCommandTitle({ commandID: 2983 })
         */
        getMenuCommandTitle(options: {
            commandID: number;
            menuID: number;
            scheduling: Scheduling;
        }): Promise<string>;
        /**
         * Invokes the menu command via its commandID. Returns false
         * on failure, or if the command is not available.
         * @example 
         * // select all
         * await PhotoshopCore.performMenuCommand({ commandID: 1017 })
         */
        performMenuCommand(options: {
            commandID: number;
            scheduling: Scheduling;
        }): Promise<boolean>;
        /**
         * Show a generic alert box to the user. 'OK' to dismiss.
         * @example 
         * // script has completed.
         * await PhotoshopCore.showAlert({ message: 'Operation successful'})
         */
        showAlert(options: {
            message: string;
        }): Promise<void>;
    }

    /**
     * Represents an action in the Actions palette. Actions are series of commands that can be recorded by user, and can be replayed
     * at a later time
     */
    interface Action {
        /**
         * 0-index of this action in it's parent action set
         */
        readonly index: number;
        /**
         * The name of this action, displayed in the panel
         * Cannot be changed
         */
        name: string;
        /**
         * The action set this action belongs to
         */
        readonly parent: ActionSet;
        /**
         * Deletes this action from the actions panel
         */
        delete(): void;
        /**
         * Creates a copy of this action, placing it in the same action set
         */
        duplicate(): Action;
        /**
         * Plays this action
         */
        play(): Promise<void>;
    }

    /**
     * Handles the content in Actions panel. The Actions panel has a hierarchy of action sets that contain a list of actions.
     */
    interface ActionSet {
        /**
         * List of actions in this action set
         */
        readonly actions: Action[];
        /**
         * 0-index of this action set in the actions palette
         */
        readonly index: number;
        /**
         * The name of this action set, displayed in the panel
         */
        name: string;
        /**
         * Deletes this action set from the actions panel
         */
        delete(): void;
        /**
         * Creates a copy of this action set
         */
        duplicate(): ActionSet;
        /**
         * Plays all actions in this set one by one
         */
        play(): Promise<void>;
    }

    /**
     * Represents a single Photoshop document that is currently open
     * You can access instances of documents using one of these methods:
     * @example 
     * // The currently active document from the Photoshop object
     * const currentDocument = app.activeDocument
     * 
     * // Choose one of the open documents from the Photoshop object
     * const secondDocument = app.documents[1]
     * 
     * // You can also create an instance of a document via a UXP File entry
     * let fileEntry = require('uxp').storage.localFileSystem.getFileForOpening()
     * const newDocument = await app.open('/project.psd')
     */
    interface Document {
        /**
         * The selected layers in the document
         * @example 
         * const layers = doc.activeLayers;
         * const topLayer = layers[0]
         */
        readonly activeLayers: Layer[];
        /**
         * Background layer, if it exists
         * @example 
         * const bgLayer = currentDocument.backgroundLayer
         */
        readonly backgroundLayer: Layer | null;
        /**
         * Document's height in pixels
         */
        readonly height: number;
        /**
         * Top level layers in the document
         */
        readonly layerTree: LayerTypes[];
        /**
         * All the layers in the document, in a flat list
         * @example 
         * const layers = currentDocument.layers
         * const topLayer = layers[0]
         */
        readonly layers: LayerTypes[];
        /**
         * Path to this document, or it's identifier if a cloud document
         */
        readonly path: string;
        /**
         * Document's resolution (in pixels per inch)
         * For example, in the default PS document (7 in wide by 5 in tall at 300 ppi)
         * @example 
         * const resolution = doc.resolution // 300
         * const width = doc.width // 2100
         * const height = doc.height // 1500
         */
        readonly resolution: number;
        /**
         * Document title
         * readonly 
         * @example 
         * const currentTitle = doc.title
         */
        readonly title: string;
        /**
         * Document's width in pixels
         */
        readonly width: number;
        /**
         * Closes the document, showing a prompt to save
         * unsaved changes if specified
         */
        close(saveDialogOptions?: SaveDialogOptions): Promise<void>;
        closeWithoutSaving(): void;
        /**
         * Create a layer. See @CreateOptions
         * @example 
         * const myEmptyLayer = await doc.createLayer()
         * const myLayer = await doc.createLayer({ name: "myLayer", opacity: 80, mode: "colorDodge" })
         */
        createLayer(options?: LayerCreateOptions): Promise<Layer | null>;
        /**
         * Create a layer group. See @CreateOptions
         * @example 
         * const myEmptyGroup = await doc.createLayerGroup()
         * const myGroup = await doc.createLayerGroup({ name: "myLayer", opacity: 80, mode: "colorDodge" })
         * const nonEmptyGroup = await doc.createLayerGroup({ name: "group", fromLayers: [layer1, layer2] })
         */
        createLayerGroup(options?: GroupLayerCreateOptions): Promise<GroupLayer | null>;
        /**
         * Crops the document to given bounds
         */
        crop(bounds: PsCommon.Bounds, angle: number): Promise<void>;
        /**
         * Duplicates given layer(s), creating all copies above the top most one in layer stack,
         * and returns the newly created layers.
         * @example 
         * // duplicate some layers
         * const layerCopies = await document.duplicateLayers([layer1, layer3])
         * layerCopies.forEach((layer) => { layer.blendMode = 'multiply' })
         * // ...to another document
         * const finalDoc = await photoshop.open('~/path/to/collated/image.psd')
         * await document.duplicateLayers([logo1, textLayer1], finalDoc)
         * await finalDoc.close(SaveDialogOptions.SAVE_CHANGES)
         */
        duplicateLayers(layers: Layer[], targetDocument?: Document): Promise<Layer[]>;
        /**
         * Flatten all layers in the document
         */
        flatten(): Promise<void>;
        /**
         * Create a layer group from existing layers.
         * @example 
         * const layers = doc.layers
         * const group = await doc.groupLayers([layers[1], layers[2], layers[4]])
         */
        groupLayers(layers: Layer[]): Promise<GroupLayer | null>;
        /**
         * Links layers together if possible, and returns a list of linked layers.
         */
        linkLayers(layers: Layer[]): Layer[];
        /**
         * Flattens all visible layers in the document
         */
        mergeVisibleLayers(): Promise<void>;
        /**
         * Changes the size of the canvas, but does not change image size
         * To change the image size, see resizeImage
         * @example 
         * // grow the canvas by 400px
         * let width = await document.width
         * let height = await document.height
         * await document.resizeCanvas(width + 400, height + 400)
         */
        resizeCanvas(width: number, height: number, anchor?: AnchorPosition): Promise<void>;
        /**
         * Changes the size of the image
         * @example 
         * await document.resizeImage(800, 600)
         */
        resizeImage(width: number, height: number, resolution?: number, resampleMethod?: ResampleMethod): Promise<void>;
        /**
         * Rotates the image clockwise in given angle, expanding canvas if necessary
         */
        rotate(angles: number): Promise<void>;
        /**
         * Saves the document or a copy, the format is deduced by the extension
         * @example 
         * // To save a document in the same location
         * document.save()
         * 
         * // Shows the save dialog
         * unsavedDocument.save()
         * 
         * // To save to a path, use UXP storage APIs to get a file for saving
         * let entry = await require('uxp').storage.localFileSystem.getFileForSaving("target.psd")
         * document.save(entry)
         * 
         * // To save to a path, but with some options:
         * document.save(entry, { embedColorProfile: true })
         */
        save(entry?: File, saveOptions?: SaveOptions): Promise<void>;
    }

    /**
     * Represents a group layer
     */
    interface GroupLayer extends Layer{
        /**
         * Inherited from [Layer]/ps_reference/classes/layer/).bounds
         * Bounds of the layer, including the effects
         * @example 
         * const { left, top, right, bottom } = layer.bounds
         */
        readonly bounds: PsCommon.Bounds;
        /**
         * Inherited from Layer.boundsNoEffects
         * Bounds of the layer excluding effects
         * @example 
         * const { left, top, right, bottom } = layer.boundsNoEffects
         */
        readonly boundsNoEffects: PsCommon.Bounds;
        /**
         * The child layers of this group layer
         * @example 
         * group.children.forEach((child) => {
         *   ...
         * })
         */
        readonly children: LayerTypes[];
        /**
         * Inherited from Layer.kind
         * Kind of the layer
         * @example 
         * if (layer.kind === LayerKind.TEXT) {
         *   ...
         * }
         */
        readonly kind: LayerKind;
        /**
         * Inherited from Layer.linkedLayers
         * Layers linked to this layer
         * @example 
         * const layers = layerAA.linkedLayers
         * layers.forEach((layer) => {
         *   ...
         * })
         */
        readonly linkedLayers: Layer[];
        /**
         * Inherited from Layer.parent
         * The group layer this layer is in,
         * null if layer has no parent
         */
        readonly parent: GroupLayer | null;
        readonly isGroupLayer: boolean;
        /**
         * Inherited from Layer.delete
         * Deletes this layer from the document.
         * number of layer elements deleted
         * @example 
         * const layers = document.layers
         * layers && layers[0] && layers[0].delete()
         */
        delete(): void;
        /**
         * Inherited from Layer.duplicate
         * Duplicates the layer, creating a copy above it in layer stack,
         * and returns the newly created layer.
         * @example 
         * // duplicate a layer
         * const copyLayer = await layer.duplicate()
         * 
         * // extract to a new document
         * const exportDoc = psApp.documents[1]
         * const exportedLayer = await layer.duplicate(exportDoc)
         */
        duplicate(targetDocument?: Document, name?: string): Promise<Layer>;
        /**
         * Inherited from Layer.flip
         * Flips the layer on one or both axis.
         * @example 
         * // flip horizontally
         * await layer.flip("horizontal")
         */
        flip(axis: "horizontal" | "vertical" | "both"): Promise<void>;
        /**
         * Inherited from Layer.link
         * Creates a link between this layer and the target layer if not already linked,
         * and returns a list of layers linked to this layer.
         * @example 
         * // link two layers together
         * const linkedLayers = strokes.link(fillLayer)
         * linkedLayers.forEach((layer) => console.log(layer.name))
         * > "strokes"
         * > "fillLayer"
         */
        link(targetLayer: Layer): Layer[];
        /**
         * Inherited from Layer.moveAbove
         * Moves the layer to a position above the target layer or group.
         * If no target layer is defined, move this layer up one slot.
         * @example 
         * foregroundLayer.moveAbove(backingLayer)
         * // foregroundLayer
         * // backingLayer
         */
        moveAbove(target?: LayerTypes): void;
        /**
         * Inherited from Layer.moveBelow
         * Moves the layer to a position below the target layer or group.
         * If no target layer is defined, move this layer down one slot.
         * @example 
         * backingLayer.moveBelow(foregroundLayer)
         * // foregroundLayer
         * // backingLayer
         */
        moveBelow(target?: LayerTypes): void;
        /**
         * Inherited from Layer.nudge
         * Moves the layer.
         * @example 
         * // nudge the layer to the left by 200px
         * await layer.nudge(-200, 0)
         * 
         * // move the layer one height down
         * let percent = (v) => ({ _unit: "percentUnit", _value: v })
         * await layer.nudge(percent(0), percent(100))
         */
        nudge(horizontal: number | PercentValue | PixelValue, vertical: number | PercentValue | PixelValue): Promise<void>;
        /**
         * Inherited from Layer.rotate
         * Rotates the layer.
         * @example 
         * // rotate 90 deg counter clockwise
         * await layer.rotate(-90)
         */
        rotate(angle: number | AngleValue, options?: {
            interpolation: InterpolationMethod;
        }): Promise<void>;
        /**
         * Inherited from Layer.scale
         * Scales the layer.
         * @example 
         * await layer.scale(80, 80)
         */
        scale(width: number | PercentValue, height: number | PercentValue, options?: {
            interpolation: InterpolationMethod;
        }): Promise<void>;
        /**
         * Inherited from Layer.skew
         * Applies a skew to the layer.
         * @example 
         * // parellelogram shape
         * await layer.skew(-15, 0)
         */
        skew(angleH: number | AngleValue, angleV: number | AngleValue, options?: {
            interpolation: InterpolationMethod;
        }): Promise<void>;
        /**
         * Inherited from Layer.unlink
         * Unlinks the layer from any existing links.
         * @example 
         * // detach layer from any existing links
         * await layer.unlink()
         */
        unlink(): Promise<void>;
    }

    /**
     * A Photoshop Layer.
     * Ultimately, this will have subclasses denoting all layer types.
     */
    interface Layer {
        /**
         * Bounds of the layer, including the effects
         * @example 
         * const { left, top, right, bottom } = layer.bounds
         */
        readonly bounds: PsCommon.Bounds;
        /**
         * Bounds of the layer excluding effects
         * @example 
         * const { left, top, right, bottom } = layer.boundsNoEffects
         */
        readonly boundsNoEffects: PsCommon.Bounds;
        /**
         * Kind of the layer
         * @example 
         * if (layer.kind === LayerKind.TEXT) {
         *   ...
         * }
         */
        readonly kind: LayerKind;
        /**
         * Layers linked to this layer
         * @example 
         * const layers = layerAA.linkedLayers
         * layers.forEach((layer) => {
         *   ...
         * })
         */
        readonly linkedLayers: Layer[];
        /**
         * The group layer this layer is in,
         * null if layer has no parent
         */
        readonly parent: GroupLayer | null;
        /**
         * Deletes this layer from the document.
         * number of layer elements deleted
         * @example 
         * const layers = document.layers
         * layers && layers[0] && layers[0].delete()
         */
        delete(): void;
        /**
         * Duplicates the layer, creating a copy above it in layer stack,
         * and returns the newly created layer.
         * @example 
         * // duplicate a layer
         * const copyLayer = await layer.duplicate()
         * 
         * // extract to a new document
         * const exportDoc = psApp.documents[1]
         * const exportedLayer = await layer.duplicate(exportDoc)
         */
        duplicate(targetDocument?: Document, name?: string): Promise<Layer>;
        /**
         * Flips the layer on one or both axis.
         * @example 
         * // flip horizontally
         * await layer.flip("horizontal")
         */
        flip(axis: "horizontal" | "vertical" | "both"): Promise<void>;
        /**
         * Creates a link between this layer and the target layer if not already linked,
         * and returns a list of layers linked to this layer.
         * @example 
         * // link two layers together
         * const linkedLayers = strokes.link(fillLayer)
         * linkedLayers.forEach((layer) => console.log(layer.name))
         * > "strokes"
         * > "fillLayer"
         */
        link(targetLayer: Layer): Layer[];
        /**
         * Moves the layer to a position above the target layer or group.
         * If no target layer is defined, move this layer up one slot.
         * @example 
         * foregroundLayer.moveAbove(backingLayer)
         * // foregroundLayer
         * // backingLayer
         */
        moveAbove(target?: LayerTypes): void;
        /**
         * Moves the layer to a position below the target layer or group.
         * If no target layer is defined, move this layer down one slot.
         * @example 
         * backingLayer.moveBelow(foregroundLayer)
         * // foregroundLayer
         * // backingLayer
         */
        moveBelow(target?: LayerTypes): void;
        /**
         * Moves the layer.
         * @example 
         * // nudge the layer to the left by 200px
         * await layer.nudge(-200, 0)
         * 
         * // move the layer one height down
         * let percent = (v) => ({ _unit: "percentUnit", _value: v })
         * await layer.nudge(percent(0), percent(100))
         */
        nudge(horizontal: number | PercentValue | PixelValue, vertical: number | PercentValue | PixelValue): Promise<void>;
        /**
         * Rotates the layer.
         * @example 
         * // rotate 90 deg counter clockwise
         * await layer.rotate(-90)
         */
        rotate(angle: number | AngleValue, options?: {
            interpolation: InterpolationMethod;
        }): Promise<void>;
        /**
         * Scales the layer.
         * @example 
         * await layer.scale(80, 80)
         */
        scale(width: number | PercentValue, height: number | PercentValue, options?: {
            interpolation: InterpolationMethod;
        }): Promise<void>;
        /**
         * Applies a skew to the layer.
         * @example 
         * // parellelogram shape
         * await layer.skew(-15, 0)
         */
        skew(angleH: number | AngleValue, angleV: number | AngleValue, options?: {
            interpolation: InterpolationMethod;
        }): Promise<void>;
        /**
         * Unlinks the layer from any existing links.
         * @example 
         * // detach layer from any existing links
         * await layer.unlink()
         */
        unlink(): Promise<void>;
    }

    /**
     * The top level application object, root of our DOM
     * From here, you can access open documents, tools, UI elements and run commands or menu items.
     * @example 
     * const app = require('photoshop').app
     */
    interface App {
        /**
         * Returns the action tree shown in Actions panel, as an array of ActionSets, each containing actions
         */
        readonly actionTree: ActionSet[];
        /**
         * The current active document
         * @example 
         * const doc = Photoshop.activeDocument;
         */
        activeDocument: Document;
        /**
         * The default background color and color style for documents.
         */
        readonly backgroundColor: Color;
        /**
         * Current selected tool. For now, the Tool class is an object with
         * only an id field. In the future, we aim to provide tools with their own classes
         */
        readonly currentTool: Tool;
        /**
         * List of currently open documents
         * @example 
         * const documents = app.documents;
         */
        readonly documents: Document[];
        /**
         * Dev environments only.
         * A callback for event notifications in Photoshop. This will cause your plugin to get a notification
         * on every event the user is doing, so it may slow things down. But it will be helpful to figure out
         * different descriptors
         * To register listeners to specific events in production, follow Event Listeners in the Advanced section.
         * @example 
         * app.eventNotifier = (event, descriptor) => {
         *    console.log(event, JSON.stringify(descriptor, null, ' '));
         * }
         */
        eventNotifier: (event: string, descriptor: object) => void | Promise<void>;
        /**
         * The default foreground color (used to paint, fill, and stroke selections)
         */
        readonly foregroundColor: Color;
        /**
         * At the heart of all our APIs is batchPlay. It is the evolution of executeAction. It accepts ActionDescriptors deserialized from JS objects, and can play multiple descriptors sequentially without updating the UI. This API is subject to change and may be accessible in other ways in the future. Learn more in our batchPlay reference.
         */
        batchPlay(commands: ActionDescriptor[], options?: BatchPlayCommandOptions): Promise<Descriptor[]>;
        /**
         * Brings application to focus, useful when your script ends, or requires an input
         */
        bringToFront(): void;
        /**
         * Create a new document. See @DocumentCreateOptions.
         * Documents not created from presets must specify width, height, resolution, (color) mode, and fill.
         * @example 
         * let newDoc1 = app.createDocument(); // creates a 2100px * 1500px document
         * let newDoc2 = app.createDocument({width: 800, height: 600, resolution: 300, mode: "RGBColorMode", fill: "transparent"});
         * let newDoc3 = app.createDocument({preset: "My Default Size 1"});
         */
        createDocument(options?: DocumentCreateOptions): Promise<Document | null>;
        /**
         * Opens the specified document and returns it's model
         * @example 
         * // Open a file given entry
         * let entry = await require('uxp').storage.localFileSystem.getFileForOpening()
         * const document = await app.open(entry);
         * 
         * // Show open file dialog
         * const document = await app.open();
         */
        open(entry?: File): Promise<Document>;
        /**
         * Shows an alert in Photoshop with the given message
         */
        showAlert(message: string): Promise<void>;
    }

    interface Selection extends Transformable{
        /**
         * The selection's rectangular bounds
         */
        readonly bounds: Promise<PsCommon.Bounds>;
        /**
         * The document this selection belongs to
         */
        readonly parent: Promise<Document>;
        /**
         * Whether the selection is solid
         */
        readonly solid: Promise<boolean>;
        /**
         * Invoke a copy command on the selection
         */
        copy(merge?: boolean): Promise<void>;
        /**
         * Invoke a cut command on the selection
         */
        cut(): Promise<void>;
        /**
         * Expands the selection by a pixel amount
         */
        expand(amount?: number): Promise<void>;
        /**
         * Feathers the selection by a pixel amount
         */
        feather(amount?: number): Promise<void>;
        /**
         * Invert the selection
         */
        invert(): Promise<void>;
        /**
         * Implementation of Transformable
         * Moves the selected pixels.
         * @example 
         * // nudge the selection to the left by 200px
         * await selection.nudge(-200, 0)
         */
        nudge(horizontal: number | PercentValue | PixelValue, vertical: number | PercentValue | PixelValue): Promise<void>;
        /**
         * Implementation of Transformable
         * Applies a distortion (perspective) to the content under the selection.
         * @example 
         * // 'into the distance' effect
         * await selection.perspectiveTransform(0, -0.05)
         */
        perspectiveTransform(percentH: number | PercentValue, percentV: number | PercentValue, interpolation?: InterpolationMethod): Promise<void>;
        /**
         * Implementation of Transformable
         * Rotates the content under the selection.
         * @example 
         * // rotate 90 deg counter clockwise
         * await selection.rotate(-90)
         */
        rotate(angle: number | AngleValue, interpolation?: InterpolationMethod): Promise<void>;
        /**
         * Implementation of Transformable
         * Scales the content under the selection.
         * @example 
         * await selection.scale(120, 120)
         */
        scale(width: number | PercentValue, height: number | PercentValue, interpolation?: InterpolationMethod): Promise<void>;
        /**
         * Implementation of Transformable
         * Applies a skew to the content under the selection.
         * @example 
         * // parellelogram shape
         * await selection.skew(-15, 0)
         */
        skew(angleH: number | AngleValue, angleV: number | AngleValue, interpolation?: InterpolationMethod): Promise<void>;
        /**
         * Translate the entire selection.
         */
        translate(deltaX: number, deltaY: number): Promise<void>;
        /**
         * Implementation of Transformable
         * Applies a warp to the content under the selection.
         * @example 
         * // perform a fisheye warp
         * await selection.warp({ style: BuiltinWarpStyle.warpFisheye, value: 70 })
         * 
         * // warp selection content using a user provided 4x4 warp grid of points
         * var bounds = await selection.bounds
         * var grid = myWarpEngine.generateUniformXYPoints(bounds, 16)
         * var warp = myWarpEngine.applyWarp(grid)
         * await selection.warp({ meshPoints: warp })
         */
        warp(warp: BuiltinWarp | CustomWarp4X4, interpolation?: InterpolationMethod): Promise<void>;
    }

}


// Part 1 - from photoshop/0_manual.d.ts
// Manually created by @hansottowirtz
declare module "photoshop" {
  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   */
  type InterpolationMethod = any;

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   */
  type ResampleMethod = any;

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   */
  type AnchorPosition = any;

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   */
  type BuiltinWarpStyle = WarpStyle;

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   */
  type LayerTypes = GroupLayer | Layer;

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   */
  type SaveDialogOptions = any;

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   */
  type CreateOptions = Partial<Layer>;

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   */
  type LayerCreateOptions = CreateOptions;

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   */
  type GroupLayerCreateOptions = CreateOptions;

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   * From https://github.com/AdobeDocs/uxp-photoshop/blob/a0aa32139d/src/pages/ps_reference/media/advanced/batchplay.md
   */
  type DocumentCreateOptions = Partial<Document>;

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   * From https://github.com/AdobeDocs/uxp-photoshop/blob/a0aa32139d/src/pages/ps_reference/media/advanced/batchplay.md
   */
  interface BatchPlayCommandOptions {
    readonly synchronousExecution?: boolean;
  }

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   * From https://github.com/AdobeDocs/uxp-photoshop/blob/a0aa32139d/src/pages/ps_reference/media/advanced/batchplay.md
   */
  interface ActionDescriptor {
    /**
     * _obj is a reserved identifier for the event of the action descriptor.
     * _obj is universally needed for all descriptors being passed into batchPlay.
     */
    _obj: string;
    /**
     * This is the ActionReference, the element on which this action should be played
     */
    _target: {
      /**
       * @example "document"
       */
      _ref: string;
      /**
       * @example "ordinal"
       */
      _enum: string;
      /**
       * @example "targetEnum"
       */
      _value: string;
    };
    [key: string]: any;
  }

  interface Layer {
    name: string;
    visible: boolean;
  }

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   * From https://github.com/AdobeDocs/uxp-photoshop/blob/a0aa32139d/src/pages/ps_reference/media/advanced/batchplay.md
   */
  type Descriptor = ActionDescriptor;

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   * From https://www.adobe.io/photoshop/uxp/ps_reference/modules/photoshopaction/#addnotificationlistener
   */
  type NotificationListener = (eventName: string, descriptor: Descriptor) => void;

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   */
  interface Tool {
    id: string;
  }

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   */
  namespace PsCommon {
    /**
     * Incomplete definition.
     * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
     */
    type Bounds = Rectangle;
  }

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   * From https://www.adobe.io/photoshop/uxp/ps_reference/interfaces/batchplaycommandoptions/
   */
  interface HistoryStateInfo {
    name: string;
    target: any;
  }

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   * From https://www.adobe.io/photoshop/uxp/ps_reference/media/advanced/cpp-pluginsdk/
   */
  interface PhotoshopMessaging {
    sendSDKPluginMessage(id: string, content: string): any;
    addSDKMessagingListener(cb: (...args: any[]) => any): void;
    removeSDKMessagingListener(cb: (...args: any[]) => any): void;
  }

  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   */
  export const app: App;
  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   */
  export const action: PhotoshopAction;
  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   */
  export const core: PhotoshopCore;
  /**
   * Incomplete definition.
   * Contibute at github.com/hansottowirtz/adobe-uxp-types-crawler
   */
  export const messaging: PhotoshopMessaging;
}

// Part 2 - from photoshop/channel.d.ts
// Manually created by @simonhenke
declare module "photoshop" {
  interface ChannelReference {
    _ref: "channel";
    _index: number;
  }

  type Channel = RGBColorChannel | CMYKColorChannel | LabColorChannel;

  const enum LabColorChannel {
    lightness = "lightness",
    a = "a",
    b = "b",
  }

  const enum RGBColorChannel {
    red = "red",
    green = "grain",
    blue = "blue",
  }

  const enum CMYKColorChannel {
    cyan = "cyan",
    magenta = "magenta",
    yellow = "yellow",
    black = "black",
  }

  interface ChannelEnum {
    _enum: "channel";
    _value: Channel;
  }
}

// Part 3 - from photoshop/color.d.ts
// Manually created by @simonhenke
declare module "photoshop" {


  /**
   * -------------------------------------------------------------------------------------------------
   * Be aware that some ColorSpaces have weird fields such a 'grain' instead of 'green'.
   * These bugs are due to double occupancy of char-codes and are firmly fixed inside PS.
   * -------------------------------------------------------------------------------------------------
   */

  type PsColor = PsRGBColorSpace | PsCMYKColorSpace | PsHSBColorSpace | LabColorSpace | GrayscaleColorSpace | OpacityColorSpace

  type ColorSpaceKeys = "RGBColor" | "HSBColorClass" | "CMYKColorClass" | "labColor" | "grayscale" | "opacityClass";

  interface ColorSpace extends BookColorProperties {
    _obj: ColorSpaceKeys
  }

  interface BookColorProperties {
    book?: string
    name?: string
    bookID?: number
    bookKey?: any
  }

  interface ColorSpaceEnum {
    _enum: "colorSpace"
    _value: ColorSpaceKeys
  }

  interface LabColorSpace extends ColorSpace {
    _obj: "labColor"
    luminance: number
    a: number
    b: number
  }
  interface GrayscaleColorSpace extends ColorSpace {
    _obj: "grayscale"
    gray: number
  }
  interface OpacityColorSpace extends ColorSpace {
    _obj: "opacityClass"
    opacity: number
  }

  const enum ColorName {
    none = 'none',
    yellowColor = 'yellowColor',
    red = 'red',
    orange = 'orange',
    green = 'green',
    blue = 'blue',
    violet = 'violet',
    gray = 'gray',
    black = 'black',
  }

  interface ColorNameEnum {
    _enum: 'color'
    _value: ColorName
  }

  interface PsRGBColorSpace extends ColorSpace {
    _obj: "RGBColor"
    red: number
    grain: number
    blue: number
  }

  interface PsCMYKColorSpace extends ColorSpace {
    _obj: "CMYKColorClass"
    cyan: number
    magenta: number
    yellowColor: number
    black: number
  }

  interface PsHSBColorSpace extends ColorSpace {
    _obj: "HSBColorClass"
    hue: UnitValue
    saturation: number
    brightness: number
  }

  /**
   * -------------------------------------------------------------------------------------------------
   * The ColorSpaces below have a more reasonable structure, that differs from the PsColors however
   * -------------------------------------------------------------------------------------------------
   */

  type Color = RGBColorSpace | HSBColorSpace | CMYKColorSpace | LabColorSpace | GrayscaleColorSpace | OpacityColorSpace;

  interface RGBColorSpace extends ColorSpace {
    _obj: "RGBColor"
    red: number
    green: number
    blue: number
  }
  interface HSBColorSpace extends ColorSpace {
    _obj: "HSBColorClass"
    hue: number
    saturation: number
    brightness: number
  }
  interface CMYKColorSpace extends ColorSpace {
    _obj: "CMYKColorClass"
    cyan: number
    magenta: number
    yellow: number
    black: number
  }
}

// Part 4 - from photoshop/common.d.ts
// Manually created by @simonhenke
declare module "photoshop" {
  const enum BlendMode {
    normal = "normal",
    dissolve = "dissolve",
    darken = "darken",
    multiply = "multiply",
    colorBurn = "colorBurn",
    linearBurn = "linearBurn",
    darkerColor = "darkerColor",
    lighten = "lighten",
    screen = "screen",
    colorDodge = "colorDodge",
    linearDodge = "linearDodge",
    lighterColor = "lighterColor",
    overlay = "overlay",
    softLight = "softLight",
    hardLight = "hardLight",
    vividLight = "vividLight",
    linearLight = "linearLight",
    pinLight = "pinLight",
    hardMix = "hardMix",
    difference = "difference",
    exclusion = "exclusion",
    subtract = "blendSubtraction",
    divide = "blendDivide",
    hue = "hue",
    saturation = "saturation",
    color = "color",
    luminosity = "luminosity",
  }

  interface BlendModeEnum {
    _enum: "blendMode";
    _value: BlendMode;
  }

  const enum StrokeStyleAlign {
    outside = "strokeStyleAlignOutside",
    inside = "strokeStyleAlignInside",
    center = "strokeStyleAlignCenter",
  }
}

// Part 5 - from photoshop/geometry.d.ts
// Manually created by @simonhenke
declare module "photoshop" {
  interface AlignmentEnum {
    _enum: "alignmentType";
    _value: Alignment;
  }

  const enum Alignment {
    left = "left",
    center = "center",
    right = "right",
    justifyLeft = "justifyLeft",
    justifyCenter = "justifyCenter",
    justifyRight = "justifyRight",
    justifyAll = "justifyAll",
  }

  const enum Direction {
    vertical = "vertical",
    horizontal = "horizontal",
  }

  interface UVRectangleDescriptor<UV extends UnitValue = UnitValue>
    extends UVTopRightBottomLeft<UV> {
    _obj: "rectangle";
    width: UV;
    height: UV;
  }

  interface PointDescriptor {
    _obj: "paint" | "point";
    horizontal: number;
    vertical: number;
  }

  interface UVPointDescriptor<UV extends UnitValue = UnitValue> {
    _obj: "paint" | "point";
    horizontal: UV;
    vertical: UV;
  }

  interface TopRightBottomleft {
    top: number;
    right: number;
    bottom: number;
    left: number;
  }

  interface UVTopRightBottomLeft<UV extends UnitValue = UnitValue> {
    top: UV;
    right: UV;
    bottom: UV;
    left: UV;
  }

  interface OrientationEnum {
    _enum: "orientation";
    _value: Orientation;
  }

  const enum Orientation {
    horizontal = "horizontal",
    vertical = "vertical",
  }

  interface RectangleDescriptor extends TopRightBottomleft {
    _obj: "rectangle";
  }

  interface PointDescriptorWidthHeight {
    _obj: "paint";
    width: number;
    height: number;
  }

  type CornersArray = [
    // [x1,y1,x2,y2,x3,y3,x4,y4]
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number
  ];
}

// Part 6 - from photoshop/gradient.d.ts
// Manually created by @simonhenke
declare module "photoshop" {
  interface GradientFormEnum {
    _enum: "gradientForm";
    _value: GradientForm;
  }

  const enum GradientForm {
    customStops = "customStops",
    colorNoise = "colorNoise",
  }

  interface ColorStopTypeEnum {
    _enum: "colorStopType";
    _value: ColorStopType;
  }

  const enum ColorStopType {
    userStop = "userStop",
    foregroundColor = "foregroundColor",
    backgroundColor = "backgroundColor",
  }

  interface ColorStopDescriptor {
    _obj: "colorStop";
    color: PsColor;
    type: ColorStopTypeEnum;
    location: number;
    midpoint: number;
  }

  interface TransparencyStopDescriptor {
    _obj: "transferSpec";
    opacity: PercentValue;
    location: number;
    midpoint: number;
  }

  type GradientDescriptor = CustomStopGradientDescriptor | NoiseGradientDescriptor;

  interface GenericGradientProperties {
    _obj: "gradientClassEvent";
    name: string;
    gradientForm: GradientFormEnum;
  }

  interface NoiseGradientDescriptor extends GenericGradientProperties {
    gradientForm: {
      _enum: "gradientForm";
      _value: GradientForm.colorNoise;
    };
    showTransparency?: boolean;
    vectorColor?: boolean;
    colorSpace?: ColorSpaceEnum;
    randomSeed?: number;
    smoothness?: number;
    minimum?: [number, number, number, number];
    maximum?: [number, number, number, number];
  }

  interface CustomStopGradientDescriptor extends GenericGradientProperties {
    gradientForm: {
      _enum: "gradientForm";
      _value: GradientForm.customStops;
    };
    interfaceIconFrameDimmed?: number;
    colors?: ColorStopDescriptor[];
    transparency?: TransparencyStopDescriptor[];
  }

  interface GradientTypeEnum {
    _enum: "gradientType";
    _value: GradientType;
  }

  const enum GradientType {
    linear = "linear",
    radial = "radial",
    angle = "angle",
    reflected = "reflected",
    diamond = "diamond",
  }
}

// Part 7 - from photoshop/layer-effects.d.ts
// Manually created by @simonhenke
declare module "photoshop" {
  interface LayerEffectsDescriptor {
    scale: PercentValue;
    dropShadow?: DropShadowDescriptor;
    dropShadowMulti?: DropShadowDescriptor[];
    innerShadow?: InnerShadowDescriptor;
    innerShadowMulti?: InnerShadowDescriptor[];
    outerGlow?: OuterGlowDescriptor;
    solidFill?: SolidFillDescriptor;
    solidFillMulti?: SolidFillDescriptor[];
    gradientFill?: GradientFillDesriptor;
    gradientFillMulti?: GradientFillDesriptor[];
    patterFill?: PatternFillDescriptor;
    frameFX?: FrameFXDescriptor;
    frameFXMulti?: FrameFXDescriptor[];
    innerGlow?: InnerGlowDescriptor;
    bevelEmboss?: BevelEmbossDescriptor;
    chromeFX?: ChromeFXDescriptor;
  }

  interface LayerFxGenericProperties {
    enabled: boolean;
    present: boolean;
    showInDialog: boolean;
    mode: BlendModeEnum;
    opacity: PercentValue;
  }

  interface ChromeFXDescriptor extends LayerFxGenericProperties {
    _obj: "chromeFX";
    color: PsColor;
    antiAlias: boolean;
    invert: boolean;
    localLightingAngle: AngleValue;
    distance: PixelValue;
    blur: PixelValue;
    mappingShape: ShapeCurveTypeDescriptor;
  }

  interface BevelTechniqueEnum {
    _enum: "bevelTechnique";
    _value: BevelTechnique;
  }

  const enum BevelTechnique {
    softMatte = "softMatte",
    preciseMatte = "preciseMatte",
    slopeLimitMatte = "slopeLimitMatte",
  }

  interface BevelEmbossStyleEnum {
    _enum: "bevelEmbossStyle";
    _value: BevelEmbossStyle;
  }

  const enum BevelEmbossStyle {
    innerBevel = "innerBevel",
    outerBevel = "outerBevel",
    emboss = "emboss",
    pillowEmboss = "pillowEmboss",
    strokeEmboss = "strokeEmboss",
  }

  interface BevelEmbossStampStyleEnum {
    _enum: "bevelEmbossStampStyle";
    _value: BevelEmbossStampStyle;
  }

  const enum BevelEmbossStampStyle {
    stampOut = "stampOut",
    in = "in",
  }

  interface BevelEmbossDescriptor {
    _obj: "bevelEmboss";
    enabled: boolean;
    present: boolean;
    showInDialog: boolean;
    highlightMode: BlendModeEnum;
    highlightColor: PsColor;
    highlightOpacity: PercentValue;
    shadowMode: BlendModeEnum;
    shadowColor: PsColor;
    shadowOpacity: PercentValue;
    bevelTechnique: BevelTechniqueEnum;
    bevelStyle: BevelEmbossStyleEnum;
    useGlobalAngle: boolean;
    localLightingAngle: AngleValue;
    localLightingAltitude: AngleValue;
    strengthRatio: PercentValue;
    blur: PixelValue;
    bevelDirection: BevelEmbossStampStyleEnum;
    transferSpec: ShapeCurveTypeDescriptor;
    antialiasGloss: boolean;
    softness: PixelValue;
    useShape: boolean;
    useTexture: boolean;
    // with Shape
    mappingShape?: ShapeCurveTypeDescriptor;
    antiAlias?: boolean;
    inputRange?: PercentValue;
    // with Texture
    invertTexture?: boolean;
    align?: boolean;
    scale?: PercentValue;
    textureDepth?: PercentValue;
    pattern?: PatternDescriptor;
    phase?: PointDescriptor;
  }

  interface InnerGlowDescriptor extends LayerFxGenericProperties {
    _obj: "innerGlow";
    color: PsColor;
    glowTechnique: MatteTechniqueEnum;
    chokeMatte: PixelValue;
    blur: PixelValue;
    noise: PercentValue;
    shadingNoise: PercentValue;
    antiAlias: boolean;
    transferSpec: ShapeCurveTypeDescriptor;
    inputRange: PercentValue;
    innerGlowSource: InnerGlowSourceTypeEnum;
  }

  interface InnerGlowSourceTypeEnum {
    _enum: "innerGlowSourceType";
    _value: InnerGlowSourceType;
  }

  const enum InnerGlowSourceType {
    edgeGlow = "edgeGlow",
    centerGlow = "centerGlow",
  }

  interface FrameFXSolidFillDescriptor extends FrameFXDescriptorBase {
    paintType: FrameFillEnum<FrameFill.solidFill>;
  }

  interface FrameFXGradientFillDescriptor
    extends FrameFXDescriptorBase,
      GradientFillProperties {
    paintType: FrameFillEnum<FrameFill.gradientFill>;
  }

  interface FrameFXPatternFillDescriptor
    extends FrameFXDescriptorBase,
      PatternFillProperties {
    paintType: FrameFillEnum<FrameFill.pattern>;
  }

  interface FrameFillEnum<FF extends FrameFill = FrameFill> {
    _enum: "frameFill";
    _value: FF;
  }

  const enum FrameFill {
    solidFill = "solidFill",
    gradientFill = "gradientFill",
    pattern = "pattern",
  }

  interface FrameStyleEnum {
    _enum: "frameStyle";
    _value: FrameStyle;
  }

  const enum FrameStyle {
    insetFrame = "insetFrame",
    outsetFrame = "outsetFrame",
    centeredFrame = "centeredFrame",
  }

  type FrameFXDescriptor =
    | FrameFXSolidFillDescriptor
    | FrameFXGradientFillDescriptor
    | FrameFXPatternFillDescriptor;

  interface FrameFXDescriptorBase extends LayerFxGenericProperties {
    _obj: "frameFX";
    style: FrameStyleEnum;
    paintType: FrameFillEnum;
    overprint: boolean;
    size: PixelValue;
    color: PsColor;
  }

  interface PatternDescriptor {
    _obj: "pattern";
    name: string;
    ID: string; // UUID
  }

  interface PatternFillProperties {
    pattern: PatternDescriptor;
    angle: AngleValue;
    scale: PercentValue;
    align: boolean;
    phase: PointDescriptor;
  }

  interface PatternFillDescriptor extends LayerFxGenericProperties, PatternFillProperties {
    _obj: "patternFill";
  }

  interface InnerShadowDescriptor extends LayerFxGenericProperties {
    _obj: "innerShadow";
    color: PsColor;
    useGlobalAngle: boolean;
    localLightingAngle: AngleValue;
    distance: PixelValue;
    chokeMatte: PixelValue;
    blur: PixelValue;
    noise: PercentValue;
    antiAlias: boolean;
    transferSpec: ShapeCurveTypeDescriptor;
  }

  interface DropShadowDescriptor extends LayerFxGenericProperties {
    _obj: "dropShadow";
    color: PsColor;
    useGlobalAngle: boolean;
    localLightingAngle: AngleValue;
    distance: PixelValue;
    chokeMatte: PixelValue;
    blur: PixelValue;
    noise: PercentValue;
    antiAlias: boolean;
    transferSpec: ShapeCurveTypeDescriptor;
    layerConceals: boolean;
  }

  interface OuterGlowDescriptor extends LayerFxGenericProperties {
    _obj: "outerGlow";
    color: PsColor;
    glowTechnique: MatteTechniqueEnum;
    chokeMatte: PixelValue;
    blur: PixelValue;
    noise: PercentValue;
    shadingNoise: PercentValue;
    antiAlias: boolean;
    transferSpec: ShapeCurveTypeDescriptor;
    inputRange: PercentValue;
  }

  interface SolidFillDescriptor extends LayerFxGenericProperties {
    _obj: "solidFill";
    color: PsColor;
  }

  interface GradientFillProperties {
    gradient: GradientDescriptor;
    angle: AngleValue;
    type: GradientTypeEnum;
    reverse: boolean;
    dither: boolean;
    align: boolean;
    scale: PercentValue;
    offset: UVPointDescriptor<PercentValue>;
  }

  interface GradientFillDesriptor extends LayerFxGenericProperties, GradientFillProperties {
    _obj: "gradientFill";
  }

  interface MatteTechniqueEnum {
    _enum: "matteTechnique";
    _value: MatteTechnique;
  }

  const enum MatteTechnique {
    softMatte = "softMatte",
    preciseMatte = "preciseMatte",
  }

  interface ShapeCurveTypeDescriptor {
    _obj: "shapeCurveType";
    name?: ShapeCurveName;
    curve?: CurvePointDescriptor[];
  }

  const enum ShapeCurveName {
    Linear = "Linear",
    Cone = "$$$/Contours/Defaults/Cone=Cone",
    ConeInverted = "$$$/Contours/Defaults/ConeInverted=Cone - Inverted",
    CoveDeep = "$$$/Contours/Defaults/CoveDeep=Cove - Deep",
    CoveShallow = "$$$/Contours/Defaults/CoveShallow=Cove - Shallow",
    Gaussian = "$$$/Contours/Defaults/Gaussian=Gaussian",
    HalfRound = "$$$/Contours/Defaults/HalfRound=Half Round",
    Ring = "$$$/Contours/Defaults/Ring=Ring",
    RingDouble = "$$$/Contours/Defaults/DoubleRing=Ring - Double",
    RollingSlopeDescending = "$$$/Contours/Defaults/RollingSlopeDescending=Rolling Slope - Descending",
    RoundedSteps = "$$$/Contours/Defaults/RoundedSteps=Rounded Steps",
    SawTooth1 = "$$$/Contours/Defaults/Sawtooth1=Sawtooth 1",
  }

  interface CurvePointDescriptor {
    _obj: "curvePoint";
    horizontal: number;
    vertical: number;
    continuity: boolean;
  }
}

// Part 8 - from photoshop/layer.d.ts
// Manually created by @simonhenke
declare module "photoshop" {
  const enum LayerKind {
    any = 0,
    pixel = 1,
    adjustment = 2,
    text = 3,
    vector = 4,
    smartObject = 5,
    video = 6,
    group = 7,
    threeD = 8,
    gradient = 9,
    pattern = 10,
    solidColor = 11,
    background = 12,
    groupEnd = 13,
  }

  interface LayerDescriptor {
    name: string;
    color: ColorNameEnum;
    visible: boolean;
    mode: BlendModeEnum;
    opacity: number;
    layerID: number;
    itemIndex: number;
    count: number;
    preserveTransparency: boolean;
    layerFXVisible: boolean;
    layerEffects: LayerEffectsDescriptor;
    globalAngle: number;
    background: boolean;
    layerSection: LayerSectionTypeEnum;
    layerLocking: LayerLockingDescriptor;
    group: boolean;
    targetChannels: ChannelReference[];
    visibleChannels: ChannelReference[];
    channelRestrictions: ChannelEnum[];
    fillOpacity: number;
    hasUserMask: boolean;
    hasVectorMask: boolean;
    proportionalScaling: boolean;
    layerKind: number;
    hasFilterMask: boolean;
    userMaskDensity: number;
    userMaskFeather: number;
    vectorMaskDensity: number;
    vectorMaskFeather: number;
    bounds: UVRectangleDescriptor<PixelValue>;
    boundsNoEffects: UVRectangleDescriptor<PixelValue>;
    boundsNoMask: UVRectangleDescriptor<PixelValue>;
    useAlignedRendering: boolean;
    generatorSettings: GeneratorSettingsDescriptor;
    keyOriginType: KeyOriginType[];
    fillEnabled: boolean;
    animationProtection: AnimationProtectionDescriptor;
    artboard: ArtboardDescriptor;
    artboardEnabled: boolean;
    vectorMaskEnabled: boolean;
    vectorMaskEmpty: boolean;
    textWarningLevel: number;
    parentLayerID: number;

    // --- Smart Object Layer
    smartObject?: SmartObjectDescriptor;
    smartObjectMore?: SmartObjectMore;
    // TODO: SmartFilters

    // --- Pattern Layer
    userMaskEnabled?: boolean;
    userMaskLinked?: boolean;

    // --- Adjustment Layer
    adjustment: Adjustment[];
  }

  interface LayerSectionTypeEnum {
    _enum: "layerSectionType";
    _value: LayerSectionType;
  }

  const enum LayerSectionType {
    layerSectionContent = "layerSectionContent",
    layerSectionStart = "layerSectionStart",
    layerSectionEnd = "layerSectionEnd",
  }

  interface LayerLockingDescriptor {
    _obj: "layerLocking";
    protectNone: boolean;
    protectAll: boolean;
    protectTransparency: boolean;
    protectComposite: boolean;
    protectPosition: boolean;
    protectArtboardAutonest: boolean;
  }

  interface GeneratorSettingsDescriptor {
    _obj: "generatorSettings";
  }

  interface AnimationProtectionDescriptor {
    _obj: "animationProtection";
    animationUnifyPosition: boolean;
    animationUnifyEffects: boolean;
    animationUnifyVisibility: boolean;
    animationPropagate: boolean;
  }

  interface FloatRectDescriptor extends TopRightBottomleft {
    _obj: "classFloatRect";
  }

  interface ArtboardDescriptor {
    _obj: "artboard";
    artboardRect: FloatRectDescriptor;
    guideIDs: number[];
    artboardPresetName: string;
    color: PsColor;
    artboardBackgroundType: number;
  }

  interface RadiiDescriptor {
    _obj: "radii";
    unitValueQuadVersion: number;
    topRight: PixelValue;
    topLeft: PixelValue;
    bottomLeft: PixelValue;
    bottomRight: PixelValue;
  }

  interface UnitRectDescriptor extends UVTopRightBottomLeft<PixelValue> {
    _obj: "unitRect";
    unitValueQuadVersion: number;
  }

  interface OriginBoxCorners {
    rectangleCornerA: PointDescriptor;
    rectangleCornerB: PointDescriptor;
    rectangleCornerC: PointDescriptor;
    rectangleCornerD: PointDescriptor;
  }

  interface KeyOriginType {
    keyOriginType: number;
    keyOriginRRectRadii: RadiiDescriptor;
    keyOriginResolution: number;
    keyOriginShapeBBox: UnitRectDescriptor;
    keyOriginBoxCorners: OriginBoxCorners;
    transform: TransformMatrixDescriptor;
    keyActionMode: number;
  }

  type Adjustment =
    | SolidColorLayerDescriptor
    | PatternDescriptor
    | GradientLayerDescriptor
    | BrightnessAndContrastDescriptor
    | LevelsDescriptor
    | CurvesDescriptor
    | ExposureDescriptor
    | VibranceDescriptor
    | HueSaturationDescriptor
    | ColorBalanceDescriptor
    | BlackAndWhiteDescriptor
    | PhotoFilterDescriptor
    | ChannelMixerDescriptor
    | ColorLookupDescriptor
    | InvertDescriptor
    | PosterizationDescriptor
    | ThresholdDescriptor
    | GradientMapDescriptor
    | SelectiveColorDescriptor;

  interface SolidColorLayerDescriptor {
    _obj: "solidColorLayer";
    color: PsColor;
  }

  interface PatternLayerDescriptor {
    _obj: "patternLayer";
    pattern: PatternDescriptor;
  }

  interface LegacyContentData {
    legacyContentData: ArrayBuffer;
  }

  interface BrightnessAndContrastDescriptor extends LegacyContentData {
    _obj: "brightnessEvent";
  }

  interface LevelsDescriptor extends LegacyContentData {
    _obj: "levels";
  }

  interface CurvesDescriptor extends LegacyContentData {
    _obj: "curves";
  }

  interface ExposureDescriptor extends LegacyContentData {
    _obj: "exposure";
  }

  interface VibranceDescriptor extends LegacyContentData {
    _obj: "vibrance";
  }

  interface HueSaturationDescriptor extends LegacyContentData {
    _obj: "hueSaturation";
  }

  interface ColorBalanceDescriptor extends LegacyContentData {
    _obj: "colorBalance";
  }

  interface BlackAndWhiteDescriptor extends LegacyContentData {
    _obj: "blackAndWhite";
  }

  interface PhotoFilterDescriptor extends LegacyContentData {
    _obj: "photoFilter";
  }

  interface ChannelMixerDescriptor extends LegacyContentData {
    _obj: "channelMixer";
  }

  interface ColorLookupDescriptor extends LegacyContentData {
    _obj: "colorLookup";
  }

  interface InvertDescriptor {
    _obj: "invert";
  }

  interface PosterizationDescriptor extends LegacyContentData {
    _obj: "posterization";
  }

  interface ThresholdDescriptor extends LegacyContentData {
    _obj: "thresholdClassEvent";
  }

  interface GradientMapDescriptor extends LegacyContentData {
    _obj: "gradientMapClass";
  }

  interface SelectiveColorDescriptor extends LegacyContentData {
    _obj: "selectiveColor";
  }

  interface GradientLayerDescriptor {
    _obj: "gradientLayer";
    angle: AngleValue;
    type: GradientType;
    gradient: GradientDescriptor;
  }
}

// Part 9 - from photoshop/path.d.ts
// Manually created by @simonhenke
declare module "photoshop" {
  interface PathDescriptor {
    ID: number;
    count: number;
    itemIndex: number;
    kind: PathKindEnum;
    pathContents: PathContentsDescriptor;
    pathName: string;
    targetPath: boolean;
  }

  interface PathKindEnum {
    _enum: "pathKind";
    _value: PathKind;
  }

  const enum PathKind {
    vectorMask = "vectorMask",
    workPath = "workPath",
    clippingPath = "clippingPath",
    normalPath = "normalPath",
  }

  interface PathContentsDescriptor {
    _obj: "pathClass";
    pathComponents: PathComponentDescriptor[];
  }

  interface ShapeOperationEnum {
    _enum: "shapeOperation";
    _value: ShapeOperation;
  }

  const enum ShapeOperation {
    add = "add",
    subtract = "subtract",
    intersect = "intersect",
    interfaceIconFrameDimmed = "interfaceIconFrameDimmed",
    xor = "xor",
  }

  interface PathComponentDescriptor {
    _obj: "pathComponent";
    shapeOperation: ShapeOperationEnum;
    subpathListKey: SubpathDescriptor[];
    windingFill?: boolean;
  }

  interface SubpathDescriptor {
    _obj: "subpathsList";
    closedSubpath: boolean;
    points: PathPointDescriptor[];
  }

  interface PathPointDescriptor {
    _obj: "pathPoint";
    anchor: UVPointDescriptor;
    backward?: UVPointDescriptor;
    forward?: UVPointDescriptor;
    smooth?: boolean;
  }
}

// Part 10 - from photoshop/save-options.d.ts

// Borrowed from https://github.com/bbb999/Types-for-Adobe/blob/master/Photoshop/2015.5/index.d.ts
declare module "photoshop" {
  /**
   * Options for saving a Photoshop document.
   */
  interface SaveOptions {
    /**
     * If true, the alpha channels are saved.
     */
    alphaChannels: boolean;

    /**
     * If true, the annotations are saved.
     */
    annotations: boolean;

    /**
     * If true, the color profile is embedded in the document.
     */
    embedColorProfile: boolean;

    /**
     * If true, the layers are saved.
     */
    layers: boolean;

    /**
     * If true, spot colors are saved.
     */
    spotColors: boolean;
  }
}

// Part 11 - from photoshop/smart-object.d.ts
// Manually created by @simonhenke
declare module "photoshop" {
  interface SmartObjectMore {
    /** uuid */
    ID: string;
    /** uuid */
    placed: string;
    pageNumber: number;
    totalPages: number;
    crop: number;
    frameStep: Fraction;
    duration: Fraction;
    frameCount: number;
    antiAliasType: number;
    type: number;
    transform: CornersArray;
    nonAffineTransform: CornersArray;
    warp: WarpDescriptorExtended;
    x: PointDescriptor;
    size: PointDescriptorWidthHeight;
    resolution: DensityValue;
    comp: number;
    compInfo: {
      compID: number;
      originalCompID: number;
    };
  }

  interface PlacedContentTypeEnum {
    _enum: "placed";
    _value: PlacedContentType;
  }

  const enum PlacedContentType {
    rasterizeContent = "rasterizeContent",
    vectorData = "vectorData",
  }

  interface SmartObjectGenericProperties {
    _obj: "smartObject";
    placed: PlacedContentTypeEnum;
    documentID: string;
    compsList: {
      compID: number;
      originalCompID: number;
    };
    linked: boolean;
    fileReference: string | FileReference;
  }

  interface LinkedSmartObjectDescriptor extends SmartObjectGenericProperties {
    link: FileReference;
    linkMissing: boolean;
    linkChanged: boolean;
  }

  interface FileReference {
    _path: string;
    _kind: FileReferenceKind;
  }

  const enum FileReferenceKind {
    local = "local",
    cloud = "cloud",
  }

  interface CloudLinkDescriptor {
    _obj: "ccLibrariesElement";
    adobeStockId: string;
    adobeStockLiceneseState: AdobeStockLiceneseStateEnum;
    dateModified: number;
    elementReference: string;
    libraryName: string;
    name: string;
  }

  interface AdobeStockLiceneseStateEnum {
    _enum: "adobeStockLiceneseState";
    _value: AdobeStockLiceneseState;
  }

  const enum AdobeStockLiceneseState {
    licensed = "licensed",
    unlicensed = "unlicensed",
  }

  type SmartObjectDescriptor = SmartObjectGenericProperties | LinkedSmartObjectDescriptor;
}

// Part 12 - from photoshop/text-key.d.ts
// Manually created by @simonhenke
declare module "photoshop" {
  interface TextKeyDescriptor {
    _obj: "textLayer";
    antiAlias: {
      _enum: "antiAliasType";
      _value: antiAliasType;
    };
    boundingBox: BoundingBoxDescriptor;
    bounds: BoundsDescriptor;
    kerningRange: KerningRangeDescriptor[];
    orientation: OrientationEnum;
    paragraphStyleRange: ParagraphStyleRangeDescriptor[];
    textClickPoint: UVPointDescriptor<PercentValue>;
    textGridding: TextGriddingEnum;
    textKey: string;
    textShape: TextShapeDescriptor[];
    textStyleRange: TextStyleRangeDescriptor[];
    warp: WarpDescriptor;
    transform?: TransformMatrixDescriptor;
  }

  interface TextStyleRangeDescriptor extends RangePartial {
    _obj: "textStyleRange";
    textStyle: TextStyleDescriptor;
  }

  interface FontCapsEnum {
    _enum: "fontCaps";
    _value: FontCaps;
  }

  const enum FontCaps {
    normal = "normal",
    smallCaps = "smallCaps",
    allCaps = "allCaps",
  }

  interface DigiSetEnum {
    _enum: "digitSet";
    _value: DigiSet;
  }

  const enum DigiSet {
    defaultDigits = "defaultDigits",
    arabicDigits = "arabicDigits",
    farsiDigits = "farsiDigits",
    hindiDigits = "hindiDigits",
  }

  interface KashidasEnum {
    _enum: "kashidas";
    _value: Kashidas;
  }

  const enum Kashidas {
    kashidaDefault = "kashidaDefault",
  }

  interface BaselineEnum {
    _enum: "baseline";
    _value: Baseline;
  }

  const enum Baseline {
    normal = "normal",
    superScript = "superScript",
    subScript = "subScript",
  }

  interface OtBaselineEnum {
    _enum: "otbaseline";
    _value: OtBaseline;
  }

  const enum OtBaseline {
    normal = "normal",
    superScript = "superScript",
    subScript = "subScript",
    numerator = "numerator",
    denominator = "denominator",
  }

  interface StrikeThroughEnum {
    _enum: "strikethrough";
    _value: StrikeThrough;
  }

  const enum StrikeThrough {
    xHeightStrikethroughOn = "xHeightStrikethroughOn",
    xHeightStrikethroughOff = "xHeightStrikethroughOff",
  }

  interface UnderlineEnum {
    _enum: "underline";
    _value: Underline;
  }

  const enum Underline {
    underlineOnLeftInVertical = "underlineOnLeftInVertical",
    underlineOnRightInVertical = "underlineOnRightInVertical",
    underlineOff = "underlineOff",
  }

  interface FigureStyleEnum {
    _enum: "figureStyle";
    _value: FigureStyle;
  }

  const enum FigureStyle {
    normal = "normal",
    tabularLining = "tabularLining",
    proportionalOldStyle = "proportionalOldStyle",
    proportionalLining = "proportionalLining",
    tabularOldStyle = "tabularOldStyle",
  }

  interface BaselineDirectionEnum {
    _enum: "baselineDirection";
    _value: BaselineDirection;
  }

  const enum BaselineDirection {
    withStream = "withStream",
    // TODO: more?
  }

  interface TextLanguageEnum {
    _enum: "textLanguage";
    _value: TextLanguage;
  }

  const enum TextLanguage {
    oldGermanLanguage = "oldGermanLanguage",
    greekLanguage = "greekLanguage",
    hungarianLanguage = "hungarianLanguage",
    icelandicLanguage = "icelandicLanguage",
    italianLanguage = "italianLanguage",
    japaneseLanguage = "japaneseLanguage",
    croatianLanguage = "croatianLanguage",
    latvianLanguage = "latvianLanguage",
    lithuanianLanguage = "lithuanianLanguage",
    nynorskNorwegianLanguage = "nynorskNorwegianLanguage",
    polishLanguage = "polishLanguage",
    romanianLanguage = "romanianLanguage",
    rumanianLanguage = "rumanianLanguage",
    russianLanguage = "russianLanguage",
    serbianLanguage = "serbianLanguage",
    slovakLanguage = "slovakLanguage",
    slovenianLanguage = "slovenianLanguage",
    spanishLanguage = "spanishLanguage",
    standardFrenchLanguage = "standardFrenchLanguage",
    standardGermanLanguage = "standardGermanLanguage",
    germanLanguageReformed1996 = "germanLanguageReformed1996",
    standardPortugueseLanguage = "standardPortugueseLanguage",
    swedishLanguage = "swedishLanguage",
    swissGermanLanguage = "swissGermanLanguage",
    swissGermanLanguageOldRules = "swissGermanLanguageOldRules",
    turkishLanguage = "turkishLanguage",
    ukenglishLanguage = "ukenglishLanguage",
    ukranianLanguage = "ukranianLanguage",
    arabicLanguage = "arabicLanguage",
    hebrewLanguage = "hebrewLanguage",
    bokmalNorwegianLanguage = "bokmalNorwegianLanguage",
    brazilianPortugueseLanguage = "brazilianPortugueseLanguage",
    bulgarianLanguage = "bulgarianLanguage",
    canadianFrenchLanguage = "canadianFrenchLanguage",
    canadianEnglishLanguage = "canadianEnglishLanguage",
    catalanLanguage = "catalanLanguage",
    chineseLanguage = "chineseLanguage",
    czechLanguage = "czechLanguage",
    danishLanguage = "danishLanguage",
    dutchLanguage = "dutchLanguage",
    kdutchLanguageOldRules = "kdutchLanguageOldRules",
    englishLanguage = "englishLanguage",
    estonianLanguage = "estonianLanguage",
    finnishLanguage = "finnishLanguage",
  }

  interface JapaneseAlternateEnum {
    _enum: "japaneseAlternate";
    _value: JapaneseAlternate;
  }

  const enum JapaneseAlternate {
    defaultForm = "defaultForm",
    traditionalForm = "traditionalForm",
    expertForm = "expertForm",
    JIS78Form = "JIS78Form",
    JIS83Form = "JIS83Form",
    halfWidthForm = "halfWidthForm",
    thirdWidthForm = "thirdWidthForm",
    quarterWidthForm = "quarterWidthForm",
    fullWidthForm = "fullWidthForm",
    proportionalWidthForm = "proportionalWidthForm",

    // expertForm?
    // traditionalForm?
    // TODO: more?
  }

  interface GridAlignmentEnum {
    _enum: "gridAlignment";
    _value: GridAlignment;
  }

  const enum GridAlignment {
    roman = "roman",
    bottom = "bottom",
    ifcbottom = "icfbottom",
    center = "center",
    icftop = "icftop",
    top = "top",
  }

  interface TextStyleDescriptor {
    _obj: "textStyle";
    styleSheetHasParent: boolean;
    fontPostScriptName: string;
    fontName: string;
    fontStyleName: string;
    fontScript: number;
    fontTechnology: number;
    fontAvailable: boolean;
    size: PointValue;
    impliedFontSize: PointValue;
    horizontalScale: number;
    verticalScale: number;
    syntheticBold: boolean;
    syntheticItalic: boolean;
    autoLeading: boolean;
    leading?: PointValue;
    impliedLeading?: PointValue;
    tracking: number;
    baselineShift: PointValue;
    impliedBaselineShift: PointValue;
    fontCaps: FontCapsEnum;
    digitSet: DigiSetEnum;
    kashidas: KashidasEnum;
    diacXOffset: PointValue;
    diacYOffset: PointValue;
    markYDistFromBaseline: PointValue;
    baseline: BaselineEnum;
    otbaseline: OtBaselineEnum;
    strikethrough: StrikeThroughEnum;
    underline: UnderlineEnum;
    ligature: boolean;
    altligature: boolean;
    contextualLigatures: boolean;
    fractions: boolean;
    ordinals: boolean;
    swash: boolean;
    titling: boolean;
    connectionForms: boolean;
    stylisticAlternates: boolean;
    stylisticSets: number;
    ornaments: boolean;
    justificationAlternates: boolean;
    figureStyle: FigureStyleEnum;
    proportionalMetrics: boolean;
    kana: boolean;
    italics: boolean;
    baselineDirection: BaselineDirectionEnum;
    textLanguage: TextLanguageEnum;
    japaneseAlternate: JapaneseAlternateEnum;
    mojiZume: number;
    gridAlignment: GridAlignmentEnum;
    noBreak: boolean;
    color: PsColor;
    strokeColor: PsColor;
    baseParentStyle: BaseParentTextStyleDescriptor;
  }

  interface AutoKernEnum {
    _enum: "autoKern";
    _value: AutoKern;
  }

  const enum AutoKern {
    metricsKern = "metricsKern",
    opticalKern = "opticalKern",
    manual = "manual",
  }

  interface DirOverrideEnum {
    _enum: "dirOverride";
    _value: DirOverride;
  }

  const enum DirOverride {
    dirOverrideDefault = "dirOverrideDefault",
    dirOverrideLTR = "dirOverrideLTR",
    dirOverrideRTL = "dirOverrideRTL",
  }

  interface DiacVPosEnum {
    _enum: "diacVPos";
    _value: DiacVPos;
  }

  const enum DiacVPos {
    diacVPosOpenType = "diacVPosOpenType",
    diacVPosOff = "diacVPosOff",
    diacVPosLoose = "diacVPosLoose",
    diacVPosMedium = "diacVPosMedium",
    diacVPosTight = "diacVPosTight",
  }

  interface WariChuJustificationEnum {
    _enum: "wariChuJustification";
    _value: WariChuJustification;
  }

  const enum WariChuJustification {
    wariChuAutoJustify = "wariChuAutoJustify",
    wariChuCenterJustify = "wariChuCenterJustify",
    wariChuFullJustifyLastLineCenter = "wariChuFullJustifyLastLineCenter",
    wariChuFullJustifyLastLineFull = "wariChuFullJustifyLastLineFull",
    wariChuFullJustifyLastLineLeft = "wariChuFullJustifyLastLineLeft",
    wariChuFullJustifyLastLineRight = "wariChuFullJustifyLastLineRight",
    wariChuLeftJustify = "wariChuLeftJustify",
    wariChuRightJustify = "wariChuRightJustify",
  }

  interface LineCapEnum {
    _enum: "lineCap";
    _value: LineCap;
  }

  const enum LineCap {
    buttCap = "buttCap",
    roundCap = "roundCap",
    squareCap = "squareCap",
  }

  interface LineJoinEnum {
    _enum: "lineJoin";
    _value: LineJoin;
  }

  const enum LineJoin {
    miterJoin = "miterJoin",
    roundJoin = "roundJoin",
    bevelJoin = "bevelJoin",
  }

  interface BaseParentTextStyleDescriptor extends TextStyleDescriptor {
    characterRotation: number;
    autoKern: AutoKernEnum;
    dirOverride: DirOverrideEnum;
    diacVPos: DiacVPosEnum;
    underlineOffset: PointValue;
    alternateLigatures: boolean;
    oldStyle: boolean;
    ruby: boolean;
    enableWariChu: boolean;
    wariChuCount: number;
    wariChuLineGap: number;
    wariChuScale: number;
    wariChuWidow: number;
    wariChuOrphan: number;
    wariChuJustification: WariChuJustificationEnum;
    tcyUpDown: number;
    tcyLeftRight: number;
    leftAki: number;
    rightAki: number;
    jiDori: number;
    fill: boolean;
    stroke: boolean;
    fillFirst: boolean;
    fillOverPrint: boolean;
    strokeOverPrint: boolean;
    lineCap: LineCapEnum;
    lineJoin: LineJoinEnum;
    lineWidth: PointValue;
    miterLimit: PointValue;
    lineDashoffset: number;
  }

  type TextShapeDescriptor = TextShapeGenericProperties | TextShapeOnPathDescriptor;

  interface TextShapeGenericProperties {
    _obj: "textShape";
    bounds: RectangleDescriptor;
    char: CharEnum;
    columnCount: number;
    columnGutter: PointValue;
    firstBaselineMinimum: PointValue;
    frameBaselineAlignment: FramBaselineAlignmentEnum;
    orientation: OrientationEnum;
    rowCount: number;
    rowGutter: PointValue;
    rowMajorOrder: boolean;
    spacing: PointValue;
    transform: TransformMatrixDescriptor;
  }

  interface TextShapeOnPathDescriptor extends TextShapeGenericProperties {
    flip: boolean;
    path: PathContentsDescriptor;
    pathTypeAlignTo: PathTypeAlignToEnum;
    pathTypeAlignment: PathTypeAlignmentEnum;
    pathTypeEffect: PathTypeEffectEnum;
    pathTypeSpacing: number;
    tRange: TRangeDescriptor;
  }

  interface TRangeDescriptor {
    _obj: "range";
    end: number;
    saturation: number;
  }

  interface PathTypeEffectEnum {
    _enum: "pathTypeEffect";
    _value: PathTypeEffect;
  }

  const enum PathTypeEffect {
    rainbowEffect = "rainbowEffect",
    // TODO: more?
  }

  interface PathTypeAlignmentEnum {
    _enum: "pathTypeAlignment";
    _value: PathTypeAlignment;
  }

  const enum PathTypeAlignment {
    baselineAlignment = "baselineAlignment",
    centerAlignment = "centerAlignment",
  }

  interface PathTypeAlignToEnum {
    _enum: "pathTypeAlignTo";
    _value: PathTypeAlignTo;
  }

  const enum PathTypeAlignTo {
    toPathTop = "toPathTop",
    toPathBottom = "toPathBottom",
    toPathCenter = "toPathCenter",
  }

  interface FramBaselineAlignmentEnum {
    _enum: "frameBaselineAlignment";
    _value: FramBaselineAlignment;
  }

  const enum FramBaselineAlignment {
    alignByAscent = "alignByAscent",
    alignByCapHeight = "alignByCapHeight",
    alignByLeading = "alignByLeading",
    alignByMinimumValueRoman = "alignByMinimumValueRoman",
    alignByMinimumValueAsian = "alignByMinimumValueAsian",
    alignByXHeight = "alignByXHeight",
  }

  interface CharEnum {
    _enum: "char";
    _value: Char;
  }

  const enum Char {
    box = "box",
    paint = "paint", // point/paint bug
  }

  interface TextGriddingEnum {
    _enum: "textGridding";
    _value: TextGridding;
  }

  const enum TextGridding {
    none = "none",
    round = "round",
    systemMetrics = "systemMetrics",
  }

  interface ParagraphStyleRangeDescriptor extends RangePartial {
    _obj: "paragraphStyleRange";
    paragraphStyle: ParagraphStyleDescriptor;
  }

  interface ParagraphStyleDescriptor {
    _obj: "paragraphStyle";
    styleSheetHasParent: true;
    align?: AlignmentEnum;
    endIndent?: PointValue;
    firstLineIndent?: PointValue;
    hyphenate?: boolean;
    impliedEndIndent?: PointValue;
    impliedFirstLineIndent?: PointValue;
    impliedSpaceAfter?: PointValue;
    impliedSpaceBefore?: PointValue;
    impliedStartIndent?: PointValue;
    spaceAfter?: PointValue;
    spaceBefore?: PointValue;
    startIndent?: PointValue;
    burasagari?: BurasagariEnum;
    kinsokuSetName?: KinsokuSetNameEnum;
    textEveryLineComposer?: boolean;
    mojiKumiName?: MojiKumiNameEnum;
  }

  interface BurasagariEnum {
    _enum: "burasagari";
    _value: Burasagari;
  }

  const enum Burasagari {
    burasagariNone = "burasagariNone",
    burasagariStandard = "burasagariStandard",
    burasagariStrong = "burasagariStrong",
  }

  interface KinsokuSetNameEnum {
    _enum: "kinsokuSetName";
    _value: KinsokuSetName;
  }

  const enum KinsokuSetName {
    None = "None",
    Hard = "Hard",
    Soft = "Soft",
  }

  interface MojiKumiNameEnum {
    _enum: "mojiKumiName";
    _value: MojiKumiName;
  }

  const enum MojiKumiName {
    Photoshop6MojiKumiNone = "Photoshop6MojiKumiNone",
    Photoshop6MojiKumiSet1 = "Photoshop6MojiKumiSet1",
    Photoshop6MojiKumiSet2 = "Photoshop6MojiKumiSet2",
    Photoshop6MojiKumiSet3 = "Photoshop6MojiKumiSet3",
    Photoshop6MojiKumiSet4 = "Photoshop6MojiKumiSet4",
  }

  const enum antiAliasType {
    antiAliasNone = "antiAliasNone",
    antiAliasSharp = "antiAliasSharp",
    antiAliasCrisp = "antiAliasCrisp",
    antiAliasStrong = "antiAliasStrong",
    antiAliasSmooth = "antiAliasSmooth",
    antiAliasPlatformLCD = "antiAliasPlatformLCD",
    antiAliasPlatformGray = "antiAliasPlatformGray",
  }

  interface BoundingBoxDescriptor extends UVTopRightBottomLeft {
    _obj: "boundingBox";
  }

  interface BoundsDescriptor extends UVTopRightBottomLeft {
    _obj: "bounds";
  }

  interface RangePartial {
    from: number;
    to: number;
  }

  interface KerningRangeDescriptor extends RangePartial {
    _obj: "kerningRange";
    kerning: number;
  }
}

// Part 13 - from photoshop/transform.d.ts
// Manually created by @simonhenke
declare module "photoshop" {
  interface TransformMatrixDescriptor {
    _obj: "transform";
    tx: number;
    ty: number;
    xx: number;
    xy: number;
    yx: number;
    yy: number;
  }

  interface WarpDescriptor {
    _obj: "warp";
    warpPerspective: number;
    warpPerspectiveOther: number;
    warpRotate: OrientationEnum;
    warpStyle: WarpStyleEnum;
    warpValue: number;
  }

  interface WarpStyleEnum {
    _enum: "warpStyle";
    _value: WarpStyle;
  }

  const enum WarpStyle {
    warpNone = "warpNone",
    warpArc = "warpArc",
    warpArcLower = "warpArcLower",
    warpArcUpper = "warpArcUpper",
    warpArch = "warpArch",
    warpBulge = "warpBulge",
    warpShellLower = "warpShellLower",
    warpShellUpper = "warpShellUpper",
    warpFlag = "warpFlag",
    warpRave = "warpRave",
    warpFish = "warpFish",
    warpRize = "warpRize",
    warpFisheye = "warpFisheye",
    warpInflate = "warpInflate",
    warpSqueeze = "warpSqueeze",
    warpTwist = "warpTwist",
  }

  interface RationalPointList {
    _objList: "rationalPoint";
    horizontal: {
      list: number[];
      _unit: Unit;
    };
    vertical: {
      list: number[];
      _unit: Unit;
    };
  }

  interface CustomEnvelopeWarpDescriptor {
    _obj: "customEnvelopeWarp";
    meshPoints: RationalPointList;
  }

  interface WarpDescriptorExtended extends WarpDescriptor {
    bounds: FloatRectDescriptor;
    uOrder: number;
    vOrder: number;
    customEnvelopeWarp: CustomEnvelopeWarpDescriptor;
  }
}

// Part 14 - from photoshop/unit.d.ts
// Manually created by @simonhenke
declare module "photoshop" {
  const enum Unit {
    angleUnit = "angleUnit",
    densityUnit = "densityUnit",
    distanceUnit = "distanceUnit",
    percentUnit = "percentUnit",
    pixelsUnit = "pixelsUnit",
    pointsUnit = "pointsUnit",
    millimetersUnit = "millimetersUnit",
    centimetersUnit = "centimetersUnit",
    inchesUnit = "inchesUnit",
    picasUnit = "picasUnit",
  }

  interface Fraction {
    numerator: number;
    denominator: number;
  }

  interface UnitValue {
    _unit: Unit;
    _value: number;
  }
  interface AngleValue extends UnitValue {
    _unit: Unit.angleUnit;
  }
  interface DensityValue extends UnitValue {
    _unit: Unit.densityUnit;
  }
  interface DistanceValue extends UnitValue {
    _unit: Unit.distanceUnit;
  }
  interface PercentValue extends UnitValue {
    _unit: Unit.percentUnit;
  }
  interface PixelValue extends UnitValue {
    _unit: Unit.pixelsUnit;
  }
  interface PointValue extends UnitValue {
    _unit: Unit.pointsUnit;
  }
  interface MillimeterValue extends UnitValue {
    _unit: Unit.millimetersUnit;
  }
  interface CentimeterValue extends UnitValue {
    _unit: Unit.centimetersUnit;
  }
  interface InchValue extends UnitValue {
    _unit: Unit.inchesUnit;
  }
  interface PicaValue extends UnitValue {
    _unit: Unit.picasUnit;
  }
}
